USES
 Documentation.ms.dict
 EngineTypes.ms.dict
 axiom_push.ms.dict
 macro.ms.dict
 core.ms.dict
 NoStrangeSymbols.ms.dict
 params.ms.dict
 NoCapsLock.ms.dict
 arrays.ms.dict
;

// ---------------------------------------------------------------------------
%REMARK 'Это всё хозяйство надо будет потом выделить в отдельный словарь'

ENGINE_WORD TYPE ModelElement
%REMARK 'Элемент модели'

PROCEDURE do_elem_func
 STRING IN aName
 ENGINE_WORD IN aSelf
 ENGINE_WORD IN aModifier
 %SUMMARY 'Реализация do_elem_func, elem_proc и elem_generator' ;
 aSelf Ctx:SetWordProducerForCompiledClass
 axiom:PushSymbol :
 aName Ctx:Parser:PushLeftDottedSymbol
 axiom:PushSymbol ModelElement
 if ( aModifier =/= nil ) then
  ( aModifier .Name Ctx:Parser:PushSymbol )
 axiom:PushSymbol in
 'Self' Ctx:Parser:PushSymbol
; // do_elem_func

MACRO elem_func
 Literal IN aName
 %SUMMARY 'Функция на элементе модели' ;
 aName .Name this.method.addr nil do_elem_func
; // elem_func

PROCEDURE do_elem_proc
 STRING IN aName
 ENGINE_WORD IN aSelf
 ENGINE_WORD IN aModifier
 %SUMMARY 'Реализация elem_proc и elem_generator' ;
 Ctx:ClearTypeInfo
 axiom:PushSymbol VOID
 aName aSelf aModifier do_elem_func
; // do_elem_proc

MACRO elem_proc
 Literal IN aName
 %SUMMARY 'Процедура на элементе модели' ;
 aName .Name this.method.addr nil do_elem_proc
; // elem_proc

MACRO elem_generator
 Literal IN aName
 %SUMMARY 'Генератор содержимого элемента' ;
 aName .Name this.method.addr nil do_elem_proc
; // elem_generator

MACRO elem_ref_proc
 Literal IN aName
 %SUMMARY 'Процедура на элементе модели, который передаётся по ссылке' ;
 aName .Name this.method.addr Addr LVALUE_MOD do_elem_proc
; // elem_ref_proc

BOOLEAN elem_func IsSummary
 %SUMMARY 
 '
  Определяет тот факт, что Self является документацией к элементу
 '
 ; // %SUMMARY
 ( Self .Name ) = '%SUM' =: Result
; // IsSummary

BOOLEAN elem_func IsModelElement
 %SUMMARY 
 '
  Определяет тот факт, что Self является "элементом модели"
 '
 ; // %SUMMARY
 '<<' Self %ST .Name StartsStr 
 AND
 ( '>>' Self %ST .Name EndsStr )
  =: Result
 //NOT ( Self .IsSummary )
  //=: Result
; // IsModelElement

ARRAY elem_func ElementList 
 Literal IN aListName
 %SUMMARY 'Возвращает итератор именованного списка на элементе' ;

 private BOOLEAN FUNCTION FilterElement 
  OBJECT IN aMember

  Result := ( aMember NotValid ! )
 ; // FilterElement
 
 private OBJECT FUNCTION MapElement 
  OBJECT IN aMember

  VAR l_Element
  aMember DO =: l_Element
  // - берём ссылку на элемент модели
  if ( l_Element IsVoid ) then
  // - пропускаем невалидные ссылки
  (
   Result := nil
  )
  else
  (
   Result := l_Element
  ) 
 ; // MapElement

 if ( Self NotValid ) then
  ( Result := [ ] )
 else
  (
   VAR l_List
   l_List := ( Self %% ( aListName .Name ) )
   
   if ( l_List NotValid ) then
    ( Result := [ ] )
   else 
    ( Result := ( ( l_List CodeIterator ) >map> MapElement >filter> FilterElement ) )
  )
; // ElementList

ARRAY elem_func Implements
 %SUMMARY 'Возвращает итератор элементов которые реализуют наш элемент' ;
 Result := ( Self .ElementList %R )
;

ARRAY elem_func Inherited
 %SUMMARY 'Возвращает итератор элементов от которого наследуется наш элемент' ;
 Result := ( Self .ElementList %G )
;

ARRAY elem_func Children
 %SUMMARY 'Возвращает итератор детей Self в "терминах определённой модели"' ;
 ( Self MembersIterator ) >filter> .IsModelElement =: Result
; // Children

ARRAY elem_func Parents
 %SUMMARY 'Возвращает итератор родителей Self в "терминах определённой модели"' ;
 ( Self LIST %P ) >filter> .IsModelElement =: Result
; // Parents

INTEGER VAR g_Indent
%REMARK 'Текущий отступ'
( g_Indent := 0 )

BOOLEAN elem_func IsElementNeedIndent
 %SUMMARY 'Определяет тот факт, что элементу нужен отступ' ;
 true =: Result
; // IsElementNeedIndent

elem_proc EnterElement
 %SUMMARY 'Начинает вывод элемента' ;
 Self .IsElementNeedIndent ? INC g_Indent
; // EnterElement

elem_proc LeaveElement
 %SUMMARY 'Заканчивает вывод элемента' ;
 Self .IsElementNeedIndent ? DEC g_Indent
; // LeaveElement

FILE VAR g_OutFile
( g_OutFile := nil )

STRING INTEGER ARRAY TYPE PRINTABLE

CONST cIndentChar ' '

PROCEDURE OutToFile
 PRINTABLE IN aValue 
 %SUMMARY 
 '
 Выводит значение в текущий файл вывода.
 С переводом каретки.
 '
 ; // %SUMMARY 

 STRING VAR l_String
 if ( aValue IsArray ) then
  ( aValue strings:Cat =: l_String )
 else
  ( aValue ToPrintable =: l_String )
 [ g_Indent cIndentChar char:Dupe l_String ] strings:Cat g_OutFile File:WriteLn
 %REMARK '- выводим элементы модели в файл, а не в стандартный вывод.'
; //OutToFile

PROCEDURE ?OutToFile
 STRING IN aValue
 %SUMMARY 
 '
 Выводит значение в текущий файл, если оно не пустое.
 С переводом каретки.
 '
 ; // %SUMMARY 
 if ( aValue =/= '' ) then
  ( aValue OutToFile )
; // ?OutToFile

FUNCTOR TYPE GENERATOR
%REMARK 'Генератор содержимого элемента'

GENERATOR VAR g_CurrentGenerator
%REMARK 'Текущий генератор'
( g_CurrentGenerator := nil )

STRING VAR g_CurrentGeneratorName
%REMARK 'Имя текущего генератора'
( g_CurrentGeneratorName := '' )

CONST cPathSep '\'

STRING FUNCTION OutFileName
 STRING right aGeneratorName
 %SUMMARY 'Имя файла для вывода' ;
 STRING VAR l_OutPath
 %REMARK 'Путь для вывода'
 sysutils:GetCurrentDir =: l_OutPath
 [ l_OutPath 
  script:FileName 
  %REMARK 'Путь к текущему скрипту'
  sysutils:ExtractFileName
  %REMARK 'Вырезаем из пути только имя файла' 
  '' sysutils:ChangeFileExt
  %REMARK 'Убираем .script' 
  '' sysutils:ChangeFileExt 
  %REMARK 'Убираем .ms' 
 ] cPathSep strings:CatSep =: l_OutPath
 l_OutPath sysutils:ForceDirectories ?ASSURE [ 'Не удалось создать директорию ' l_OutPath ]
 %REMARK 'Создаём директорию рекурсивно, если её ещё не было'
 [ l_OutPath aGeneratorName ] cPathSep strings:CatSep =: Result
; // OutFileName

elem_proc CallCurrentGen
 FILE VAR l_PrevOutFile
 l_PrevOutFile := g_OutFile
 INTEGER VAR l_PrevIndent
 l_PrevIndent := g_Indent
 TRY
  TRY
   g_OutFile := ( OutFileName ( Self .Name (+) '.' (+) g_CurrentGeneratorName ) File:OpenWrite )
   TRY
    g_CurrentGenerator IsNil ! ?ASSURE 'Текущй генератор пустой'
    Self ( g_CurrentGenerator DO )
    %REMARK 'Вызываем на элементе генератор g_CurrentGenerator'
   FINALLY
    g_OutFile := nil
   END // TRY..FINALLY
  FINALLY
   g_OutFile := l_PrevOutFile
   l_PrevOutFile := nil
  END
 FINALLY
  g_Indent := l_PrevIndent
 END
; // CallCurrentGen

elem_proc Child.CallCurrentGen
 %SUMMARY 'Вызывает на ДОЧЕРНЕМ элементе генератор g_CurrentGenerator с учётом отступов' ;
 Self .EnterElement 
 TRY
  Self .CallCurrentGen
  //Self g_CurrentGenerator DO
  %REMARK 'Вызываем генератор g_CurrentGenerator'
 FINALLY
  Self .LeaveElement 
 END // TRY..FINALLY
; // Child.CallCurrentGen

elem_proc CallChildrenCurrentGen
 %SUMMARY 'Вызывает текущий генератор для всех детей элемента модели' ;
 for ( Self .Children ) .Child.CallCurrentGen
; // CallChildrenCurrentGen

WordAlias .generate.children .CallChildrenCurrentGen

CONST GEN_PROPERTY_PREFIX 'gp'
%REMARK 'Префикс имени свойства генератора'

MACRO %GEN_PROPERTY
 Literal IN aName
 %SUMMARY 'Свойство генератора' ;
 this.method.addr Ctx:SetWordProducerForCompiledClass
 axiom:PushSymbol CONST
 GEN_PROPERTY_PREFIX (+) ( aName .Name ) Ctx:Parser:PushSymbol
; // %GEN_PROPERTY

USES
 RefDeepest.ms.dict
;

REF operator FieldByNameDeepest
 LVALUE aSelf
 Literal IN aName
 %SUMMARY 'Метод получения вложенного члена слова по имени. С учётом того, что может быть передана ссылка на переменную' ;

 ENGINE_WORD VAR l_Self
 aSelf Dereference =: l_Self
 
 STRING VAR l_Name
 aName .Name =: l_Name
 
 OBJECT VAR l_Res
 l_Self %% l_Name =: l_Res
 
 ASSURE 
  NOT ( l_Res pop:object:IsNil ) 
  [ 'Не найдено поле: ' l_Self LIST %P Reverted ==> ( .Name '::' ) l_Self .Name '::' l_Name ]
 l_Res =: Result
; // FieldByNameDeepest

MACRO %GP
 Literal IN aName
 %SUMMARY 'Метод получения свойства генератора' ;
 axiom:PushSymbol FieldByNameDeepest
 GEN_PROPERTY_PREFIX (+) ( aName .Name ) Ctx:Parser:PushSymbol
; // %GP

elem_proc CallGen
 GENERATOR RIGHT IN aGen

 %SUMMARY 
 '
 Вызывает на элементе генератор aGen.
 С открытием "правильных файлов".
 ' 
 ; // %SUMMARY 

 aGen Dereference =: g_CurrentGenerator
 TRY
  aGen %GP Name =: g_CurrentGeneratorName
  Self .CallCurrentGen
 FINALLY
  g_CurrentGenerator := nil
 END
; // CallGen

PROCEDURE CallGens
 ARRAY IN anElements
 ARRAY IN aGenerators
 %SUMMARY 'Вызывает все определённые генераторы на элементах массива anElements' ;
 for anElements (
  ModelElement IN anElement
  for aGenerators ( 
   GENERATOR IN aGen 
   anElement .CallGen aGen
   %REMARK 'Вызываем на элементе anElement генератор aGen' 
  ) // for aGenerators
 ) // for anElements
; // CallGens

PROCEDURE CallGensList
 Sequence LVALUE anElements
 Sequence LVALUE aGenerators
 ( anElements CodeIterator )
  ( aGenerators CodeIterator )
   CallGens
; // CallGensList

WordAlias generate CallGensList

// ---------------------------------------------------------------------------
